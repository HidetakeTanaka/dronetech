#!/usr/bin/env python3
import numpy as np
import cv2
from cv2 import aruco

import rclpy
from rclpy.node import Node
from rclpy.qos import QoSProfile, ReliabilityPolicy, HistoryPolicy

from sensor_msgs.msg import Image, CameraInfo
from visualization_msgs.msg import Marker, MarkerArray
from std_msgs.msg import Header
from px4_msgs.msg import ManualControlSetpoint
from cv_bridge import CvBridge

class PrecisionLandingNode(Node):
    def __init__(self):
        super().__init__('precision_landing_node')

        # Params (tune as needed)
        self.declare_parameter('target_id', 0)
        self.declare_parameter('marker_length', 0.16)
        self.declare_parameter('enable_assist', False)   # start False; enable later
        self.declare_parameter('px4_ns', 'protoflyer')   # PX4 namespace
        self.declare_parameter('aruco_dict', 'DICT_4X4_50')

        self.target_id     = int(self.get_parameter('target_id').value)
        self.marker_length = float(self.get_parameter('marker_length').value)
        self.enable_assist = bool(self.get_parameter('enable_assist').value)
        self.px4_ns        = str(self.get_parameter('px4_ns').value)
        dict_name          = str(self.get_parameter('aruco_dict').value)

        # ArUco detector
        dict_id = getattr(aruco, dict_name)
        predef  = aruco.getPredefinedDictionary(dict_id)
        params  = aruco.DetectorParameters()
        self.detector = aruco.ArucoDetector(predef, params)

        # QoS for camera topics
        qos = QoSProfile(
            reliability=ReliabilityPolicy.BEST_EFFORT,
            history=HistoryPolicy.KEEP_LAST,
            depth=5
        )

        # State
        self.bridge = CvBridge()
        self.camera_matrix = None
        self.dist_coeffs   = None

        # I/O (relative to node namespace)
        self.sub_img  = self.create_subscription(Image,      'image',       self.on_image,  qos)
        self.sub_info = self.create_subscription(CameraInfo, 'camera_info', self.on_info,   qos)

        self.pub_markers = self.create_publisher(MarkerArray, 'detected_aruco_markers', 10)
        self.pub_debug   = self.create_publisher(Image,       'aruco_debug_image',       10)

        # PX4 manual control (absolute path)
        self.pub_px4 = self.create_publisher(
            ManualControlSetpoint,
            f'/{self.px4_ns}/fmu/in/manual_control_input',
            10
        )

        self.get_logger().info('PrecisionLandingNode initialized (Humble).')

    def on_info(self, msg: CameraInfo):
        if self.camera_matrix is None:
            self.camera_matrix = np.array(msg.k, dtype=np.float32).reshape(3, 3)
            self.dist_coeffs   = np.array(msg.d, dtype=np.float32)
            self.get_logger().info('Camera intrinsics received.')

    def on_image(self, msg: Image):
        if self.camera_matrix is None:
            return

        frame = self.bridge.imgmsg_to_cv2(msg, desired_encoding='bgr8')
        gray  = cv2.cvtColor(frame, cv2.COLOR_BGR2GRAY)

        corners, ids, _ = self.detector.detectMarkers(gray)
        markers_msg = MarkerArray()

        if ids is not None and len(ids) > 0:
            aruco.drawDetectedMarkers(frame, corners, ids)
            rvecs, tvecs, _ = aruco.estimatePoseSingleMarkers(
                corners, self.marker_length, self.camera_matrix, self.dist_coeffs
            )

            for i, aruco_id in enumerate(ids.flatten()):
                rvec, tvec = rvecs[i][0], tvecs[i][0]
                cv2.drawFrameAxes(frame, self.camera_matrix, self.dist_coeffs, rvec, tvec, 0.08)

                m = Marker()
                m.header = Header(frame_id='camera_link', stamp=msg.header.stamp)
                m.ns = 'aruco'
                m.id = int(aruco_id)
                m.type = Marker.CUBE
                m.action = Marker.ADD
                m.scale.x = self.marker_length
                m.scale.y = self.marker_length
                m.scale.z = 0.01
                m.color.r = 0.0; m.color.g = 1.0; m.color.b = 0.0; m.color.a = 0.85
                m.pose.position.x = float(tvec[0])
                m.pose.position.y = float(tvec[1])
                m.pose.position.z = float(tvec[2])
                markers_msg.markers.append(m)

            self.pub_markers.publish(markers_msg)

            # Optional assisted nudge toward target
            if self.enable_assist and (self.target_id in ids.flatten()):
                import numpy as np
                idx  = int(np.where(ids.flatten() == self.target_id)[0][0])
                tvec = tvecs[idx][0]  # [x,y,z] in camera frame (m)

                ex, ey, dz = tvec[0], tvec[1], tvec[2]
                K_xy = 0.6
                K_z  = 0.15

                roll   = float(np.clip(-K_xy * ex, -0.4, 0.4))
                pitch  = float(np.clip(-K_xy * ey, -0.4, 0.4))
                thrust = float(np.clip(-K_z  * (dz - 0.6), -0.3, 0.3))

                m = ManualControlSetpoint()
                m.timestamp = self.get_clock().now().nanoseconds // 1000  # µs
                m.x = pitch; m.y = roll; m.z = thrust; m.r = 0.0
                m.buttons = 0
                self.pub_px4.publish(m)

        self.pub_debug.publish(self.bridge.cv2_to_imgmsg(frame, encoding='bgr8'))

def main():
    rclpy.init()
    node = PrecisionLandingNode()
    rclpy.spin(node)
    node.destroy_node()
    rclpy.shutdown()

if __name__ == '__main__':
    main()
